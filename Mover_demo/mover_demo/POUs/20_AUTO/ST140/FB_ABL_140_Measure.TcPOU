<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.6">
  <POU Name="FB_ABL_140_Measure" Id="{b7a8416a-9bcd-4b4d-a0e5-3f4f2d536212}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_ABL_140_Measure
(****************************************************************************************)
(*	TITEL				laden kristall- Modul	    										*)
(*	Status				ungetestet                         								*)
(*	Beschrieb:			Ablaufbeschreibung												*)
(*																						*)
(*	Steps:	self-explained using enum													*)
(***********************************Revisionen*******************************************)
(*	see github blames																	*)
(****************************************************************************************)

VAR_INPUT
    xIN_Reset       : BOOL;          // Schrittkette zurücksetzen 
    xIN_Init        : BOOL;          // Initialisieren
    xIN_Quit        : BOOL;          // Fehler quittieren 
    xIN_Start       : BOOL;          // Startbefehl
    xIN_Sperre      : BOOL;          // FB Sperren 
    xIN_NextStep    : BOOL;          // Nächsten Schritt ausführen 
    xIN_AlarmAktiv  : BOOL;          // Anlage hat Alarm
    xIN_DryCycle    : BOOL;          // Fahren ohne Teile
    xIN_RestartCYCL : BOOL;          // Zyklus erneut starten im STEP: END: LEERFAHREN
    enIN_State      : enState;       // Status Anlage
    tIN_Timeout     : TIME := T#10s; // Timout

    pxFG_Freigabe : POINTER TO BOOL; //Freigabe von Station

    // Application specific
    Mover : REFERENCE TO FB_Mover;
END_VAR
VAR_OUTPUT
    (* standart Ausgänge *)
    xOUT_ErrFlag  : BOOL;            // Error Flag 
    xOUT_Busy     : BOOL;            // Baustein befindet sich im Ablauf 
    xOUT_Done     : BOOL;            // Baustein hat den Ablauf beendet 		
    xOUT_Ready    : BOOL;            // Ready to begin: should be the same state as done	
    xOUT_Timeout  : BOOL;            // Timeout FB 
    xOUT_InitDone : BOOL;            // initialisierung fertig
    xOUT_Wait     : BOOL;            // Wartet auf Bedingung
    iOUT_Step     : ST140_Measure_e; // Aktueller Schritt 
    sOUT_Step     : STRING;          // Aktueller Schritt but in string format
    bOUT_Error    : BYTE;            // Fehlernummer

    iOUT_ProcessCompletion : INT;  //process completion: express in % (0-100)
    xOUT_MoverFree         : BOOL; // The mover is free to move

END_VAR
VAR
    (* Standard *)
    (* Schritt *)
    iLastStep : ST140_Measure_e; // Merker letzter Schritt 
    iPreStep  : ST140_Measure_e; // Schritt zurück nach Alarm 
    iAktStep  : ST140_Measure_e; // aktueller Schritt

    // Trigger Starten 
    rtSTART : R_TRIG;
    // Timer TimeOut 
    TON_Timeout : TON;

    (* Bausteine *)
    arr_rMeasureTrack_Right : ARRAY[0..1] OF ARRAY[0..MEASURE_PER_PIECE - 1] OF REAL;
    arr_rMeasureTrack_Left  : ARRAY[0..1] OF ARRAY[0..MEASURE_PER_PIECE - 1] OF REAL;

    i            : INT;
    measureIndex : INT; // measure index

    testLevel_OK : BOOL; // TRUE when all measured level are OK

    visu_shuttle_x_position : LREAL; // position of the shuttle used in visu

END_VAR
VAR CONSTANT
    MEASURE_SIMULATION : BOOL := TRUE; // Set to TRUE to simulate this part of the program
    MEASURE_PER_PIECE  : INT  := 3;     // this must be greater than 1 !
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*******************************************************************)
(* Trigger  *)
(*******************************************************************)
(* Zurücksetzen *)
IF xIN_RESET THEN
    iPreStep  := ST140_Measure_e.RESET;
    iOUT_Step := ST140_Measure_e.RESET;
END_IF;

(* Error Quittieren *)
IF (bOUT_Error <> 0) AND xIN_Quit THEN
    xOUT_ErrFlag := FALSE;
    bOUT_Error   := 0;
    iOUT_Step    := ST140_Measure_e.READY; // iPreStep;
END_IF;

(*******************************************************************)
(* Timer *)
(*******************************************************************)
TON_Timeout(IN := xIN_NextStep AND (iLastStep = iOUT_Step) (*todo FG *) ,
            PT := tIN_Timeout);

(*******************************************************************)
(* Bausteine *)
(*******************************************************************)

(*******************************************************************)
(* OUTPUTS *)
(*******************************************************************)
// Error Flag
xOUT_ErrFlag := (bOUT_Error <> 0) OR (ST140_Measure_e.ERROR = iOUT_Step);
// Baustein befindet sich im Ablauf 
xOUT_Busy := (iOUT_Step > ST140_Measure_e.READY) AND (iOUT_Step < ST140_Measure_e.DONE);
// Baustein hat den Ablauf beendet
xOUT_Done := (iOUT_Step = ST140_Measure_e.DONE);
// Process ready
xOUT_Ready := (iOUT_Step = ST140_Measure_e.READY);
// Timeout FB 				 		
xOUT_Timeout := TON_Timeout.Q;
// Itialisierung fertig			
xOUT_InitDone := (iOUT_Step = ST140_Measure_e.READY) OR
                 (iOUT_Step = ST140_Measure_e.DONE);

// Aktueller Schritt			
iOUT_Step := iOUT_Step; //Im Ablauf gesetzt		
sOUT_Step := TO_STRING(iOUT_Step);
//Fehlernummer	 
bOUT_Error := bOUT_Error; //Im Ablauf/FB gesetzt	
(* Warte (alle Schritte wo auf FG oder Teile gewartet wird) *)
xOUT_Wait := (iOUT_Step = ST140_Measure_e.DONE);

xOUT_MoverFree := NOT (iOUT_Step >= ST140_Measure_e.MOVER_NEEDED_OP AND iOUT_Step < ST140_Measure_e.MOVER_FREE_OP);

iOUT_ProcessCompletion := F_GetPercent_2(iOUT_Step,
                                         ST140_Measure_e.waitOnMover,
                                         ST140_Measure_e.DONE,
                                         ST140_Measure_e.waitOnMover,
                                         ST140_Measure_e.DONE);

(*******************************************************************)
(* Ablauf *)
(*******************************************************************)

(* Sperren *)
IF xIN_Sperre THEN
    iPreStep  := ST140_Measure_e.RESET;
    iOUT_Step := ST140_Measure_e.RESET;
    RETURN;
END_IF;

(* Schritt Merker *)
IF iAktStep <> iOUT_Step THEN
    iLastStep := iAktStep;
    iAktStep  := iOUT_Step;
END_IF

(* START *)
rtSTART(CLK := xIN_Start);

IF __ISVALIDREF(Mover) THEN
    visu_shuttle_x_position := Mover.MovingProcessOffset;
ELSE
    visu_shuttle_x_position := 0.0;
END_IF

IF 0 = bOUT_Error THEN
    // put error conditions here
ELSIF iOUT_Step < ST140_Measure_e.ERROR THEN
    iOUT_Step := ST140_Measure_e.ERROR;
END_IF

(*******************************************************************)
(* Schrittkette  *)
(*******************************************************************)
CASE iOUT_Step OF

(***** RESET *****)
ST140_Measure_e.RESET: (* Schritt 0-99 *)
    //Initialisierungen
    //Start Init Ablauf
    IF xIN_Init THEN
        iOUT_Step := ST140_Measure_e.INIT;
        //Start Manu Ablauf
    ELSIF enIN_State = StateMANU AND xIN_NextStep THEN
        iOUT_Step := ST140_Measure_e.INIT;
    END_IF;

(***** INIT *****)
ST140_Measure_e.INIT: (* Grundstellung ? *)
    IF MEASURE_PER_PIECE < 2 THEN
        bOUT_Error := 4;
    END_IF

    iOUT_Step := ST140_Measure_e.READY;

(***** READY / INIT DONE *****)
ST140_Measure_e.READY: (* Start AUTO:END:LEER:STEP *)
    IF xIN_Start THEN  //IF rtSTART.Q THEN
        iOUT_Step := ST140_Measure_e.START;
    END_IF

(***** START  ZYKLISCH *****)
ST140_Measure_e.START: (*  *)
    IF xIN_NextStep AND pxFG_Freigabe^ THEN
        iOUT_Step := ST140_Measure_e.waitOnMover;
    END_IF;

ST140_Measure_e.waitOnMover:
    IF xIN_NextStep AND __ISVALIDREF(Mover) OR HMI.bArForceCyclusState[StationList_e.ST140] THEN
        IF Mover.GetLastStationDone() >= INT#140 THEN
            iOUT_Step := ST140_Measure_e.SYNC_MOVER_LEAVE;
		ELSIF Mover.GetLastStationDone() < INT#130 THEN
            iOUT_Step := ST140_Measure_e.SYNC_MOVER_LEAVE;
        ELSE
            MEMSET(ADR(arr_rMeasureTrack_Right), 0, SIZEOF(arr_rMeasureTrack_Right));
            MEMSET(ADR(arr_rMeasureTrack_Left), 0, SIZEOF(arr_rMeasureTrack_Left));

            measureIndex := 0;
            iOUT_Step    := ST140_Measure_e.Measure_right;
        END_IF
    END_IF

ST140_Measure_e.Measure_right:
    IF xIN_NextStep AND TRUE THEN
        arr_rMeasureTrack_Right[LaserPlace_e.NearTrack][measureIndex] :=
            UINT_TO_REAL(IN.AI01_ST140_level_track_side) * 0.001;

        arr_rMeasureTrack_Right[LaserPlace_e.NearDoor][measureIndex] :=
            UINT_TO_REAL(IN.AI02_ST140_level_door_side) * 0.001;

        measureIndex := measureIndex + 1;

        IF measureIndex >= MEASURE_PER_PIECE THEN
            IF _20_AUTO.recipe.st140.xIsTypeMiniOrSmart THEN
                iOUT_Step := ST140_Measure_e.Move_shuttle_to_pos_left;
            ELSE
                iOUT_Step := ST140_Measure_e.Save_result_in_mover;
            END_IF

            iOUT_Step := ST140_Measure_e.Move_shuttle_to_pos_left;
        ELSE
            iOUT_Step := ST140_Measure_e.Move_shuttle_relative_right;
        END_IF
    END_IF

ST140_Measure_e.Move_shuttle_relative_right:
    IF __ISVALIDREF(Mover) THEN
        IF Mover.MoveRelativeInsideStation(20.0 / (MEASURE_PER_PIECE - 1)) THEN
            iOUT_Step := ST140_Measure_e.Measure_right;
        END_IF
    ELSE
        bOUT_Error := 10;
    END_IF

ST140_Measure_e.Move_shuttle_to_pos_left:
    IF __ISVALIDREF(Mover) THEN
        IF _20_AUTO.recipe.st140.xIsTypeMiniOrSmart THEN
            IF Mover.MoveRelativeInsideStation(100.0) THEN
                iOUT_Step    := ST140_Measure_e.Measure_left;
                measureIndex := 0;
            END_IF
        ELSE
            iOUT_Step := ST140_Measure_e.Save_result_in_mover;
        END_IF
    ELSE
        bOUT_Error := 11;
    END_IF

ST140_Measure_e.Measure_left:
    IF xIN_NextStep AND __ISVALIDREF(Mover) AND_THEN Mover.IsInStationPos() THEN
        arr_rMeasureTrack_Left[LaserPlace_e.NearTrack][measureIndex] :=
            UINT_TO_REAL(IN.AI01_ST140_level_track_side) * 0.001;

        arr_rMeasureTrack_Left[LaserPlace_e.NearDoor][measureIndex] :=
            UINT_TO_REAL(IN.AI02_ST140_level_door_side) * 0.001;

        measureIndex := measureIndex + 1;

        IF measureIndex >= MEASURE_PER_PIECE THEN
            iOUT_Step := ST140_Measure_e.Save_result_in_mover;
        ELSE
            iOUT_Step := ST140_Measure_e.Move_shuttle_relative_left;
        END_IF
    END_IF

ST140_Measure_e.Move_shuttle_relative_left:
    IF __ISVALIDREF(Mover) THEN
        IF Mover.MoveRelativeInsideStation(20.0 / (MEASURE_PER_PIECE - 1)) THEN
            iOUT_Step := ST140_Measure_e.Measure_left;
        END_IF
    ELSE
        bOUT_Error := 12;
    END_IF

ST140_Measure_e.Save_result_in_mover:

    testLevel_OK := TRUE;

    IF NOT (MEASURE_SIMULATION AND CONST.USE_SIMULATION) THEN

        FOR i := 0 TO MEASURE_PER_PIECE BY 1 DO
            IF arr_rMeasureTrack_Right[i][LaserPlace_e.NearTrack] < _20_AUTO.recipe.st140.rMinHeightSensorRight OR
               arr_rMeasureTrack_Right[i][LaserPlace_e.NearTrack] > _20_AUTO.recipe.st140.rMaxHeightSensorRight OR
               arr_rMeasureTrack_Right[i][LaserPlace_e.NearDoor] < _20_AUTO.recipe.st140.rMinHeightSensorRight OR
               arr_rMeasureTrack_Right[i][LaserPlace_e.NearDoor] > _20_AUTO.recipe.st140.rMaxHeightSensorRight THEN
                testLevel_OK := FALSE;
            END_IF
        END_FOR

        IF _20_AUTO.recipe.st140.xIsTypeMiniOrSmart THEN
            FOR i := 0 TO MEASURE_PER_PIECE BY 1 DO
                IF arr_rMeasureTrack_Left[i][LaserPlace_e.NearTrack] < _20_AUTO.recipe.st140.rMinHeightSensorLeft OR
                   arr_rMeasureTrack_Left[i][LaserPlace_e.NearTrack] > _20_AUTO.recipe.st140.rMaxHeightSensorLeft OR
                   arr_rMeasureTrack_Left[i][LaserPlace_e.NearDoor] < _20_AUTO.recipe.st140.rMinHeightSensorLeft OR
                   arr_rMeasureTrack_Left[i][LaserPlace_e.NearDoor] > _20_AUTO.recipe.st140.rMaxHeightSensorLeft THEN
                    testLevel_OK := FALSE;
                END_IF
            END_FOR
        END_IF

    END_IF

    IF NOT testLevel_OK THEN
        IF __ISVALIDREF(Mover) THEN
            IF NOT Mover.SetLastStation(-140) THEN
                ASSERT(0);
            END_IF
        END_IF

        bOUT_Error := 1;
    ELSE
        IF __ISVALIDREF(Mover) THEN
            IF NOT Mover.SetLastStation(140) THEN
                ASSERT(0);
            END_IF
        END_IF
    END_IF

    iOUT_Step := ST140_Measure_e.SYNC_MOVER_LEAVE;

ST140_Measure_e.SYNC_MOVER_LEAVE:
    // The mover needs to be taken by MoverMan
    IF NOT __ISVALIDREF(Mover) THEN
        iOUT_Step := ST140_Measure_e.DONE;
    END_IF

(***** DONE *****)
ST140_Measure_e.DONE: (* Letzter Schritt  *)
    IF NOT xIN_AlarmAktiv THEN
        //AUTO
        IF (enIN_State = StateAUTO) AND xIN_RestartCYCL THEN
            iOUT_Step := ST140_Measure_e.START;
            //STEP / END / LEERFAHREN restart
        ELSIF (enIN_State < StateAUTO) AND (enIN_State >= enState.StateSTEP) AND xIN_RestartCYCL THEN
            iOUT_Step := ST140_Measure_e.START;
            //STEP / END / LEERFAHREN fertig
        ELSIF (enIN_State = StateREADY) THEN
            iOUT_Step := ST140_Measure_e.READY;
        END_IF;
    END_IF;

(************ ERROR *************)
ST140_Measure_e.ERROR: (* ERROR *) ;

END_CASE;
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>