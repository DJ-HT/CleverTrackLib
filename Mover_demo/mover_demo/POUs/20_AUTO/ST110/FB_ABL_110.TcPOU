<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.6">
  <POU Name="FB_ABL_110" Id="{de37258f-ffab-4124-a1ed-e35be9345f92}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_ABL_110
(****************************************************************************************)
(*	TITEL				RFID-Ring laden		    										*)
(*	Status				ungetestet                         								*)
(*	Beschrieb:			Ablaufbeschreibung												*)
(*																						*)
(*	Steps:	self-explained using enum													*)
(***********************************Revisionen*******************************************)
(*	see github blames																	*)
(****************************************************************************************)

VAR_INPUT
    xIN_Reset       : BOOL;          // Schrittkette zurücksetzen 
    xIN_Init        : BOOL;          // Initialisieren
    xIN_Quit        : BOOL;          // Fehler quittieren 
    xIN_Start       : BOOL;          // Startbefehl
    xIN_Sperre      : BOOL;          // FB Sperren 
    xIN_NextStep    : BOOL;          // Nächsten Schritt ausführen 
    xIN_AlarmAktiv  : BOOL;          // Anlage hat Alarm
    xIN_DryCycle    : BOOL;          // Fahren ohne Teile
    xIN_RestartCYCL : BOOL;          // Zyklus erneut starten im STEP, END, LEERFAHREN
    enIN_State      : enState;       // Status Anlage
    tIN_Timeout     : TIME := T#10s; // Timout

    pxFG_Freigabe : POINTER TO BOOL; //Freigabe von Station

    // Application specific
    iProcessTimeMili1 : UDINT := 5000; // user defined station duration, in milisecond
    iProcessTimeMili2 : UDINT := 5000; // user defined station duration, in milisecond
    Mover             : REFERENCE TO FB_Mover;
    //xIN_MoverInPos  : BOOL;          // Set this flag when a mover is in position and ready to be handled
END_VAR
VAR_OUTPUT
    (* standart Ausgänge *)
    xOUT_ErrFlag  : BOOL;    // Error Flag 
    xOUT_Busy     : BOOL;    // Baustein befindet sich im Ablauf 
    xOUT_Done     : BOOL;    // Baustein hat den Ablauf beendet 		
    xOUT_Ready    : BOOL;    // Ready to begin, should be the same state as done	
    xOUT_Timeout  : BOOL;    // Timeout FB 
    xOUT_InitDone : BOOL;    // initialisierung fertig
    xOUT_Wait     : BOOL;    // Wartet auf Bedingung
    iOUT_Step     : ST110_e; // Aktueller Schritt 
    sOUT_Step     : STRING;  // Aktueller Schritt but in string format
    bOUT_Error    : BYTE;    // Fehlernummer

    iOUT_ProcessCompletion : INT;  //process completion, express in % (0-100)
    xOUT_MoverFree         : BOOL; // The mover is free to move
    //xOUT_MoverNeeded : BOOL;   // A mover is needed by this station to continue its process
END_VAR
VAR
    (* Standard *)
    (* Schritt *)
    iLastStep : ST110_e; // Merker letzter Schritt 
    iPreStep  : ST110_e; // Schritt zurück nach Alarm 
    iAktStep  : ST110_e; // aktueller Schritt

    // Trigger Starten 
    rtSTART : R_TRIG;
    // Timer TimeOut 
    TON_Timeout : TON;

    (* Bausteine *)

    (* Spezial *)
    udiStartProcessTimeMili : UDINT; // start of the processing time, accurate at 100ns 

    udiWaitTimeBetweenStep : UDINT; // waiting time between 2 steps

    fb_axis110_01Y : FB_AxisLM_V1_1;
    fb_axis110_02Z : FB_AxisLIN_V1_1;
    fb_axis110_03Z : FB_AxisLIN_V1_1;

    fb_simu_axis110_01Y : FB_Simu_AxisLM_V1_1;

END_VAR
VAR CONSTANT
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*******************************************************************)
(* Trigger  *)
(*******************************************************************)
(* Zurücksetzen *)
IF xIN_RESET THEN
    iPreStep  := ST110_e.RESET;
    iOUT_Step := ST110_e.RESET;
END_IF;

(* Error Quittieren *)
IF (bOUT_Error <> 0) AND xIN_Quit THEN
    xOUT_ErrFlag := FALSE;
    bOUT_Error   := 0;
    iOUT_Step    := iPreStep;
END_IF;

(*******************************************************************)
(* Timer *)
(*******************************************************************)
TON_Timeout(IN := xIN_NextStep AND (iLastStep = iOUT_Step) (*todo FG *) ,
            PT := tIN_Timeout);

(*******************************************************************)
(* Bausteine *)
(*******************************************************************)
fb_axis110_01Y(enIN_State       := enIN_State,
               parIN_Buttons    := ADR(AXIS.btTeachArAxis),
               xIN_DisButtons   := FALSE,
               xIN_Quit         := xIN_Quit,
               xIN_PARAMok      := TRUE, (*TODO*)
               xIN_FREE         := TRUE,
               xIN_FREE_HOME    := TRUE,
               rIN_POSMIN       := ST110_Axis.const110_01Y.POS_MIN,
               rIN_POSMAX       := ST110_Axis.const110_01Y.POS_MAX,
               rIN_VELOMAX      := ST110_Axis.const110_01Y.VELO_MAX,
               rIN_VELOMANU     := ST110_Axis.const110_01Y.VELO_MANU,
               rIN_VELOOPEN     := ST110_Axis.const110_01Y.VELO_MANU / 4,
               rIN_JogInc       := AXIS.rTeachIncAxis,
               xIN_Execute      :=,
               xIN_Relative     :=,
               rIN_Position     :=,
               rIN_Velocity     := 100, // always move at 100%
               rIN_Acceleration :=,
               rIN_Deceleration :=,
               rIN_Jerk         :=,
               xIN_Reset        := xIN_Reset,
               axisIN_REF       := ST110_Axis.axis110_01Y.axis);

fb_simu_axis110_01Y(bIN_AxisCntr        := fb_axis110_01Y.bOUT_AxisCntr,
                    udiIN_HomingTime_ms := 2000,
                    wOUT_AxisState      => fb_axis110_01Y.wAxisState);

fb_axis110_02Z(enIN_State       := enIN_State,
               parIN_Buttons    := ADR(AXIS.btTeachArAxis),
               xIN_DisButtons   := FALSE,
               xIN_Quit         := xIN_Quit,
               axisIN_REF       := ST110_Axis.axis110_02Z.axis,
               xIN_AX5000       := FALSE,
               xIN_ENC_ABS      := TRUE, // TODO set accordingly
               xIN_PARAMok      := TRUE,
               xIN_FREE         := TRUE,
               xIN_FREE_HOME    := TRUE,
               rIN_POSMIN       := ST110_Axis.const110_02Z.POS_MIN,
               rIN_POSMAX       := ST110_Axis.const110_02Z.POS_MAX,
               rIN_VELOMAX      := ST110_Axis.const110_02Z.VELO_MAX,
               rIN_VELOMANU     := ST110_Axis.const110_02Z.VELO_MANU,
               rIN_VELOOPEN     := ST110_Axis.const110_02Z.POS_MAX / 4,
               rIN_JogInc       := AXIS.rTeachIncAxis,
               rIN_JogVelo      :=,
               xIN_HomeExe      :=,
               xIN_HomeCalib    :=,
               xIN_Execute      :=,
               xIN_Relative     :=,
               rIN_Position     :=,
               rIN_Velocity     :=,
               rIN_Acceleration :=,
               rIN_Deceleration :=,
               rIN_Jerk         :=,
               xIN_Reset        := xIN_Reset,

               // output
               xOUT_ErrFlag =>,
               xOUT_READY   =>,
               xOUT_DONE    =>,
               bOUT_Error   =>,
               rOUT_ActPos  =>);

fb_axis110_03Z(enIN_State       := enIN_State,
               parIN_Buttons    := ADR(AXIS.btTeachArAxis),
               xIN_DisButtons   := FALSE,
               xIN_Quit         := xIN_Quit,
               xIN_PARAMok      := TRUE, (*TODO*)
               xIN_FREE         := TRUE,
               xIN_FREE_HOME    := TRUE,
               rIN_POSMIN       := ST110_Axis.const110_03Z.POS_MIN,
               rIN_POSMAX       := ST110_Axis.const110_03Z.POS_MAX,
               rIN_VELOMAX      := ST110_Axis.const110_03Z.VELO_MAX,
               rIN_VELOMANU     := ST110_Axis.const110_03Z.VELO_MANU,
               rIN_VELOOPEN     := ST110_Axis.const110_03Z.VELO_MANU / 4,
               rIN_JogInc       := AXIS.rTeachIncAxis,
               xIN_Execute      :=,
               xIN_Relative     :=,
               rIN_Position     :=,
               rIN_Acceleration :=,
               rIN_Deceleration :=,
               rIN_Jerk         :=,
               xIN_Reset        := xIN_Reset,
               axisIN_REF       := ST110_Axis.axis110_03Z.axis,
               xIN_AX5000       := FALSE,
               xIN_ENC_ABS      := TRUE); // TODO set accordingly

(*******************************************************************)
(* OUTPUTS *)
(*******************************************************************)
// Error Flag 
xOUT_ErrFlag := (bOUT_Error <> 0);
// Baustein befindet sich im Ablauf 
xOUT_Busy := (iOUT_Step > ST110_e.READY) AND (iOUT_Step < ST110_e.DONE);
// Baustein hat den Ablauf beendet
xOUT_Done := (iOUT_Step = ST110_e.DONE);
// Process ready
xOUT_Ready := (iOUT_Step = ST110_e.READY);
// Timeout FB 				 		
xOUT_Timeout := TON_Timeout.Q;
// Itialisierung fertig			
xOUT_InitDone := (iOUT_Step = ST110_e.READY);
// Aktueller Schritt			
iOUT_Step := iOUT_Step; //Im Ablauf gesetzt		
sOUT_Step := TO_STRING(iOUT_Step);
//Fehlernummer	 
bOUT_Error := bOUT_Error; //Im Ablauf/FB gesetzt	
(* Warte (alle Schritte wo auf FG oder Teile gewartet wird) *)
xOUT_Wait := (iOUT_Step = ST110_e.DONE);

xOUT_MoverFree := iOUT_Step >= ST110_e.MOVER_FREE_OP AND iOUT_Step < ST110_e.MOVER_NEEDED_OP;

iOUT_ProcessCompletion := F_GetPercent_2(iAktStep,
                                         ST110_e.PnP_Hor_ToRotTablePos,
                                         ST110_e.PnP_Hor_ToTrackPos,
                                         ST110_e.PnP_Ver_ShuttleDown,
                                         ST110_e.PnP_Ver_ShuttleUp);

(*******************************************************************)
(* Ablauf *)
(*******************************************************************)

(* Sperren *)
IF xIN_Sperre THEN
    iPreStep  := ST110_e.RESET;
    iOUT_Step := ST110_e.RESET;
    RETURN;
END_IF;

(* Schritt Merker *)
IF iAktStep <> iOUT_Step THEN
    iLastStep := iAktStep;
    iAktStep  := iOUT_Step;
END_IF

(* START *)
rtSTART(CLK := xIN_Start);

(*******************************************************************)
(* Schrittkette  *)
(*******************************************************************)
CASE iOUT_Step OF

(***** RESET *****)
ST110_e.RESET: (* Schritt 0-99 *)
    //Initialisierungen
    //Start Init Ablauf
    IF xIN_Init THEN
        fb_axis110_01Y.xIN_Reset := TRUE;
        fb_axis110_02Z.xIN_Reset := TRUE;
        fb_axis110_03Z.xIN_Reset := TRUE;
        iOUT_Step                := ST110_e.ResetAxis_releaseSignal;
        //Start Manu Ablauf
    ELSIF enIN_State = StateMANU AND xIN_NextStep THEN
        iOUT_Step := ST110_e.ResetAxis_releaseSignal;
    END_IF;

ST110_e.ResetAxis_releaseSignal:
    fb_axis110_01Y.xIN_Reset := FALSE;
    fb_axis110_02Z.xIN_Reset := FALSE;
    fb_axis110_03Z.xIN_Reset := FALSE;
    iOUT_Step                := ST110_e.INIT;

(***** INIT *****)
ST110_e.INIT: (* Grundstellung ? *)
    IF FALSE THEN
        iOUT_Step := ST110_e.READY;
    ELSE
        iOUT_Step                  := ST110_e.HomeVerticals_start;
        fb_axis110_01Y.xIN_Execute := FALSE;
        fb_axis110_02Z.xIN_Execute := FALSE;
        fb_axis110_03Z.xIN_Execute := FALSE;
    END_IF;

ST110_e.HomeVerticals_start:
    IF fb_axis110_02Z.xOUT_READY AND fb_axis110_03Z.xOUT_READY THEN
        iOUT_Step := ST110_e.MoveVerticalsUp_start;
    ELSE
        fb_axis110_02Z.xIN_HomeExe := TRUE;
        fb_axis110_03Z.xIN_HomeExe := TRUE;
        iOUT_Step                  := ST110_e.HomeVerticals_waitDone;
    END_IF

ST110_e.HomeVerticals_waitDone:
    IF fb_axis110_02Z.xOUT_DONE AND fb_axis110_03Z.xOUT_DONE THEN
        fb_axis110_02Z.xIN_HomeExe := FALSE;
        fb_axis110_03Z.xIN_HomeExe := FALSE;
        iOUT_Step                  := ST110_e.MoveVerticalsUp_start;
    END_IF

st110_e.MoveVerticalsUp_start:
    fb_axis110_02Z.xIN_Execute  := TRUE;
    fb_axis110_02Z.rIN_Position := -5.0;
    fb_axis110_03Z.xIN_Execute  := TRUE;
    fb_axis110_03Z.rIN_Position := -5.0;
    iOUT_Step                   := ST110_e.MoveVerticalsUp_waitDone;

st110_e.MoveVerticalsUp_waitDone:
    IF fb_axis110_02Z.xOUT_DONE AND fb_axis110_03Z.xOUT_DONE THEN
        fb_axis110_02Z.xIN_Execute := FALSE;
        fb_axis110_03Z.xIN_Execute := FALSE;
        iOUT_Step                  := ST110_e.HomeHorizontals_start;
    END_IF

ST110_e.HomeHorizontals_start:
    IF fb_axis110_01Y.xOUT_READY OR fb_axis110_01Y.xOUT_HOMED THEN
        iOUT_Step := ST110_e.MoveHorizontalsToTrack_start;
    ELSE
        fb_axis110_01Y.xIN_Home := TRUE;
        iOUT_Step               := ST110_e.HomeHorizontals_waitDone;
    END_IF

ST110_e.HomeHorizontals_waitDone:
    IF fb_axis110_01Y.xOUT_HOMED THEN
        fb_axis110_01Y.xIN_Home := FALSE;
        iOUT_Step               := ST110_e.READY;
    END_IF

st110_e.MoveHorizontalsToTrack_start:
    fb_axis110_01Y.rIN_Position := -5.0;
    iOUT_Step                   := ST110_e.MoveHorizontalsToTrack_waitDone;

st110_e.MoveHorizontalsToTrack_waitDone:
    IF fb_axis110_01Y.xOUT_DONE THEN
        fb_axis110_01Y.xIN_Execute := FALSE;
        iOUT_Step                  := ST110_e.READY;
    END_IF

(***** READY / INIT DONE *****)
ST110_e.READY:        (* Start AUTO,END,LEER,STEP *)
    IF xIN_Start THEN //IF rtSTART.Q THEN
        iOUT_Step := ST110_e.START;
    END_IF

(***** START  ZYKLISCH *****)
ST110_e.START: (*  *)
    IF xIN_NextStep AND pxFG_Freigabe^ THEN
        iOUT_Step               := ST110_e.PnP_Hor_ToRotTablePos;
        udiStartProcessTimeMili := GetTick();
        udiWaitTimeBetweenStep  := 500;
    END_IF;

ST110_e.PnP_Hor_ToRotTablePos:
    IF xIN_NextStep AND (GetTick() - udiStartProcessTimeMili) >= (udiWaitTimeBetweenStep) THEN
        iOUT_Step              := ST110_e.PnP_Ver_RotTableDown;
        udiWaitTimeBetweenStep := udiWaitTimeBetweenStep + 500;
    END_IF;

//110.02Z	P+P handl. vertic.
ST110_e.PnP_Ver_RotTableDown:
    IF xIN_NextStep AND (GetTick() - udiStartProcessTimeMili) >= (udiWaitTimeBetweenStep) THEN
        iOUT_Step              := ST110_e.Vacum_on;
        udiWaitTimeBetweenStep := udiWaitTimeBetweenStep + 200;
    END_IF;

ST110_e.Vacum_on:
    IF xIN_NextStep AND (GetTick() - udiStartProcessTimeMili) >= (udiWaitTimeBetweenStep) THEN
        iOUT_Step              := ST110_e.PnP_Ver_RotTableUp;
        udiWaitTimeBetweenStep := udiWaitTimeBetweenStep + 500;
    END_IF;

//110.03Z	P+P handl. vertic.
ST110_e.PnP_Ver_RotTableUp:
    IF xIN_NextStep AND (GetTick() - udiStartProcessTimeMili) >= (udiWaitTimeBetweenStep) THEN
        iOUT_Step              := ST110_e.PnP_Hor_ToTrackPos;
        udiWaitTimeBetweenStep := udiWaitTimeBetweenStep + 500;
    END_IF;

//110.01Y	P+P handl. horiz.
ST110_e.PnP_Hor_ToTrackPos:
    IF xIN_NextStep AND (GetTick() - udiStartProcessTimeMili) >= (udiWaitTimeBetweenStep) THEN
        iOUT_Step              := ST110_e.waitOnMover;
        udiWaitTimeBetweenStep := udiWaitTimeBetweenStep;
    END_IF;

ST110_e.waitOnMover: (*  *)
    IF xIN_NextStep AND __ISVALIDREF(Mover) THEN
        udiStartProcessTimeMili := GetTick();
        iOUT_Step               := ST110_e.PnP_Ver_ShuttleDown;
        udiWaitTimeBetweenStep  := 400;
    END_IF;

//110.02Z	P+P handl. vertic.
//110.03Z	P+P handl. vertic.
ST110_e.PnP_Ver_ShuttleDown:
    IF xIN_NextStep AND (GetTick() - udiStartProcessTimeMili) >= (udiWaitTimeBetweenStep) THEN
        iOUT_Step              := ST110_e.PnP_Ver_ShuttleTorqueControl;
        udiWaitTimeBetweenStep := udiWaitTimeBetweenStep + 400;
    END_IF;

//110,55	Force Controll
//110,56	Force Controll
ST110_e.PnP_Ver_ShuttleTorqueControl:
    IF xIN_NextStep AND (GetTick() - udiStartProcessTimeMili) >= (udiWaitTimeBetweenStep) THEN
        iOUT_Step              := ST110_e.Vacum_off;
        udiWaitTimeBetweenStep := udiWaitTimeBetweenStep + 200;
    END_IF;

//110,05	Vacuum gripper
//110,06	Vacuum gripper
ST110_e.Vacum_off:
    IF xIN_NextStep AND (GetTick() - udiStartProcessTimeMili) >= (udiWaitTimeBetweenStep) THEN
        iOUT_Step              := ST110_e.PnP_Ver_ShuttleUp;
        udiWaitTimeBetweenStep := udiWaitTimeBetweenStep + 500;
    END_IF;

//110.02Z	P+P handl. vertic.
//110.03Z	P+P handl. vertic.
ST110_e.PnP_Ver_ShuttleUp:
    IF xIN_NextStep AND (GetTick() - udiStartProcessTimeMili) >= (udiWaitTimeBetweenStep) THEN
        iOUT_Step              := ST110_e.SYNC_MOVER_LEAVE;
        udiWaitTimeBetweenStep := udiWaitTimeBetweenStep + 500;
    END_IF;

ST110_e.SYNC_MOVER_LEAVE:
    // The mover needs to be taken by MoverMan
    IF NOT __ISVALIDREF(Mover) THEN
        iOUT_Step := ST110_e.DONE;
    END_IF

(***** DONE *****)
ST110_e.DONE: (* Letzter Schritt  *)
    IF NOT xIN_AlarmAktiv THEN
        //AUTO
        IF (enIN_State = StateAUTO) AND xIN_RestartCYCL THEN
            iOUT_Step := ST110_e.START;
            //STEP / END / LEERFAHREN restart
        ELSIF (enIN_State < StateAUTO) AND (enIN_State >= enState.StateSTEP) AND xIN_RestartCYCL THEN
            iOUT_Step := ST110_e.START;
            //STEP / END / LEERFAHREN fertig
        ELSIF (enIN_State = StateREADY) THEN
            iOUT_Step := ST110_e.READY;
        END_IF;
    END_IF;

(************ ERROR *************)
ST110_e.ERROR: (* ERROR *) ;

END_CASE;
(*
fb_axis110_01Y.xIN_Execute := iOUT_Step = ST110_e.HomeHorizontals OR
                              iOUT_Step = ST110_e.MoveHorizontalsToTrack;
							  *)
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>